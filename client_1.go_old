package flagrc

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/antihax/optional"
	"github.com/checkr/goflagr"
)

//Todo find a good timeout
var defaultTimeout time.Duration = 300 * time.Microsecond

type Evaluator interface {
	PostEvaluation(ctx context.Context, body goflagr.EvalContext) (goflagr.EvalResult, *http.Response, error)
	PostEvaluationBatch(ctx context.Context, body goflagr.EvaluationBatchRequest) (goflagr.EvaluationBatchResponse, *http.Response, error)

	withConfig
}

type withConfig interface {
	WithRefresh(refresh time.Duration)
	WithTimeout(timeout time.Duration)
}

type config struct {
	Refresh time.Duration
	Timeout time.Duration
}

type evaluator struct {
	client *goflagr.APIClient
	cache  []goflagr.Flag
	ticker *time.Ticker
	config config
}

func NewClient(cfg *goflagr.Configuration, refresh time.Duration) Evaluator {

	e := evaluator{
		client: goflagr.NewAPIClient(cfg),
		ticker: time.NewTicker(refresh),
		config: config{Refresh: refresh, Timeout: defaultTimeout},
	}

	go func() {
		for {
			select {
			case _ = <-e.ticker.C:
				_ = e.refreshCache() //TODO check the error
			}
		}
	}()

	return &e
}

func (e *evaluator) WithRefresh(refresh time.Duration) {
	e.config.Refresh = refresh
	e.ticker = time.NewTicker(refresh)
}

func (e *evaluator) WithTimeout(timeout time.Duration) {
	e.config.Timeout = timeout
}

func (e *evaluator) refreshCache() error {
	wait := make(chan bool)
	errch := make(chan error)
	ctx, cancel := context.WithTimeout(context.Background(), e.config.Timeout)
	defer cancel()

	go func(done chan bool, errch chan error) {

		// https://checkr.github.io/flagr/api_docs/#operation/findFlags
		flags, _, err := e.client.FlagApi.FindFlags(ctx, &goflagr.FindFlagsOpts{Enabled: optional.NewBool(true), Preload: optional.NewBool(true)})
		if err != nil {
			errch <- fmt.Errorf("error trying to refresh the cache, %v", err)
		}

		e.cache = flags

		done <- true

	}(wait, errch)

	select {
	case <-wait:
		return nil
	case returnErr := <-errch:
		return returnErr
	case <-ctx.Done():
		return fmt.Errorf("error trying to refresh the cache, %v", ctx.Err()) // timeout
	}
}

func (e *evaluator) PostEvaluation(ctx context.Context, body goflagr.EvalContext) (goflagr.EvalResult, *http.Response, error) {
	if body.EntityID != "" {
		return e.client.EvaluationApi.PostEvaluation(ctx, body)
	}

	// Evaluate locally
	//todo cf https://github.com/checkr/flagr/blob/master/pkg/handler/eval.go
	return goflagr.EvalResult{}, nil, nil

}

func (e *evaluator) PostEvaluationBatch(ctx context.Context, body goflagr.EvaluationBatchRequest) (goflagr.EvaluationBatchResponse, *http.Response, error) {
	for _, entity := range body.Entities {
		if entity.EntityID != "" {
			return e.client.EvaluationApi.PostEvaluationBatch(ctx, body)
		}
	}

	// EvaluateBatch locally
	//todo cf https://github.com/checkr/flagr/blob/master/pkg/handler/eval.go
	return goflagr.EvaluationBatchResponse{}, nil, nil
}
